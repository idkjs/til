<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible">
    <title>Alphabetical List of Forth Words</title>
    <style type="text/css">
    body {
        background-color: #ccc;
        font-family: Lato, "Helvetica Neue", HelveticaNeue, Helvetica, Arial, sans-serif;
        font-size: 1em;
        color: #222;
    }
    article {
        width: 840px;
        margin: auto;
    }
    h1 {
        font-size: 2em;
    }
    h1, h2, h3 {
        color: #1c1c1c;
    }
    code {
        font-family: "Source Code Pro", Monaco, Menlo, Consolas, "Courier New", monospace;
        font-weight: bold;
    }
    pre {
        font-family: "Source Code Pro", Monaco, Menlo, Consolas, "Courier New", monospace;
        font-size: .9em;
    }
    p {
        text-indent: 2em;
    }
    hr {
        border-top: 1px solid #666;
        border-bottom: 1px solid #ccc;
    }
    </style>
</head>
<body>

<article>

<a href="http://astro.pas.rochester.edu/Forth/forth-words.html">Original</a>
<br>
<a href="#floatingpointwords">Go to floating point words.</a>

<h1>Non-Floating Point Words</h1>

<a href="#store">!</a>
<a href="#quote">"</a>
<a href="#number">#</a>
<a href="#dollar">$</a>
<a href="#ampersand">&amp;</a>
<a href="#tick">'</a>
<a href="#paren">(</a>
<a href="#star">*</a>
<a href="#plus">+</a>
<a href="#comma">,</a>
<a href="#minus">-</a>
<a href="#dot">.</a>
<a href="#slash">/</a>

<a href="#digit">0123456789</a>

<a href="#colon">:</a>
<a href="#lessthan">&lt;</a>
<a href="#equals">=</a>
<a href="#to">&gt;</a>
<a href="#question">?</a>
<a href="#fetch">@</a>

<a href="#a">a</a>
<a href="#b">b</a>
<a href="#c">c</a>
<a href="#d">d</a>
<a href="#e">e</a>
<a href="#f">f</a>
<a href="#g">g</a>
<a href="#h">h</a>
<a href="#i">i</a>
<a href="#j">j</a>
<a href="#k">k</a>
<a href="#l">l</a>
<a href="#m">m</a>
<a href="#n">n</a>
<a href="#o">o</a>
<a href="#p">p</a>
<a href="#q">q</a>
<a href="#r">r</a>
<a href="#s">s</a>
<a href="#t">t</a>
<a href="#u">u</a>
<a href="#v">v</a>
<a href="#w">w</a>
<a href="#x">x</a>
<a href="#y">y</a>
<a href="#z">z</a>

<a href="#bracket">[</a>
<a href="#backslash">\</a>
<a href="#rbracket">]</a>
<a href="#caret">^</a>
<a href="#curly">{</a>

<hr>
<a name="store"><h1>!</h1></a>

<code>!  ( n adr  -- )</code>
    <p>Stores a number at adr</p>

<code>!csp  ( -- )</code>
    <p>Remembers the stack pointer</p>

<hr>
<a name="quote"><h1>"</h1></a>
<code>"  ( -- adr len )    ccc"</code>
    <p>Collects a string from the input stream</p>

<code>"" ( -- adr )    ccc</code>
    <p>Collects a word from the input stream</p>

<code>",  ( adr len -- )</code>
    <p>Places a string at the top of the dictionary</p>

<code>".  ( adr -- )</code>
    <p>Displays a packed string.  Equivalent to COUNT TYPE</p>

<code>"chdir  ( string -- )</code>
    <p>Changes to the directory whose name is the packed string "string"</p>

<code>"command  ( string --  )</code>
    <p>Executes the system command line contained in the packed string "string"</p>

<code>"compile  ( string -- )</code>
    <p>Compiles or interprets a word</p>

<code>"copy  ( fromadr toadr -- )</code>
    <p>Copies a packed string from fromadr to toadr</p>

<code>"create  ( str -- )</code>
    <p>Defines a word from a string on the stack</p>

<code>"load  ( filename -- )</code>
    <p>Interprets the file whose name is the packed string on the stack</p>

<code>"temp  ( -- str )</code>
    <p>Converts a digit in pictured numeric output</p>

<hr>
<a name="number"><h1>#</h1></a>
<code>#&gt;  ( l  --  adr +n )</code>
    <p>Ends pictured numeric output</p>

<code>#align  ( -- n )</code>
    <p>The alignment granularity for the cpu; 2 for 68000</p>

<code>#line  ( -- adr )</code>
    <p>User variable containing the line number on the output device</p>

<code>#out  ( -- adr )</code>
    <p>User variable containing the column number on the output device</p>

<code>#s  ( +l  --  0  )</code>
    <p>Converts the rest of the digits in pictured numeric output</p>

<code>#threads  ( -- n )</code>
    <p>The number of threads used by the dictionary hashing scheme</p>

<code>#tib  ( -- adr )</code>
    <p>Size of Terminal Input Buffer</p>

<code>#user  ( -- n )</code>
    <p>The first unused USER area offset</p>

<code>#vocs  ( -- n )</code>
    <p>The number of vocabularies that can be in the search order at one time</p>

<hr>
<a name="dollar"><h1>$</h1></a>

<hr>
<a name="ampersand"><h1>&amp;</h1></a>

<hr>
<a name="tick"><h1>'</h1></a>

<code>'  ( -- acf )    name</code>
    <p>Finds a word in the dictionary</p>

<code>'user#  ( -- user# )    name</code>
    <p>Finds the user number associated with the word if there is one</p>

<code>'word  ( -- adr )</code>
    <p>The address where WORD puts its string</p>

<hr>
<a name="paren"><h1>(</h1></a>

<code>(  ( -- )</code>
    <p>Begins a comment</p>

<code>(")  ( -- adr len )</code>
    <p>Run-time word compiled by "</p>

<code>("s)  ( -- adr )</code>
    <p>Run-time word compiled by [""]</p>

<code>(')  ( -- acf )</code>
    <p>Run-time word compiled by [']</p>

<code>(+loop)  ( n -- )</code>
    <p>Run-time word compiled by +LOOP</p>

<code>(.")  ( -- )</code>
    <p>Run-time word compiled by ."</p>

<code>(.)  ( n -- adr len )</code>
    <p>Converts a signed number to a character string</p>

<code>(.s  ( -- )</code>
    <p>Displays the contents of the data stack</p>

<code>(;code)  ( -- )</code>
    <p>Run-time word compiled by ;CODE and DOES&gt;</p>

<code>(?do)  ( end start -- )</code>
    <p>Run-time word compiled by ?DO</p>

<code>(abort")  ( flag -- )</code>
    <p>Run-time word compiled by ABORT"</p>

<code>(compile)  ( acf -- )</code>
    <p>Compiles a compilation address into the dictionary</p>

<code>(do)  ( end start -- )</code>
    <p>Run-time word compiled by DO</p>

<code>(does)  ( -- )</code>
    <p>Run-time word compiled by DOES&gt;</p>

<code>(interpret  ( -- )</code>
    <p>The Default implementation of INTERPRET</p>

<code>(is)  ( action-acf -- )</code>
    <p>Run-time word compiled by IS</p>

<code>(lit)  ( -- n )</code>
    <p>Run-time word compiled by DO-LITERAL</p>

<code>(llit)  ( -- l )</code>
    <p>Run-time word compiled by DO-LITERAL</p>

<code>(loop)  ( -- )</code>
    <p>Run-time word compiled by LOOP</p>

<code>(s  ( -- )    stack-comment</code>
    <p>Alternate form of stack comment</p>

<code>(see)  ( acf -- )</code>
    <p>Decompiles the word</p>

<code>(u.)  ( u -- adr len )</code>
    <p>Converts an unsigned number to a character string</p>

<code>(where  ( -- )</code>
    <p>The Default implementation of WHERE</p>


<hr>
<a name="star"><h1>*</h1></a>

<code>*  ( n1 n2  --  n3 )</code>
    <p>Multiplies n1 times n2</p>

<hr>
<a name="plus"><h1>+</h1></a>

<code>+  ( n1 n2 -- n3 )</code>
    <p>Adds n1+n2</p>

<code>+!  ( n adr -- )</code>
    <p>Adds n to the number stored at adr</p>

<code>+loop  ( n -- )</code>
    <p>Ends DO .. +LOOP construct; adds n to loop index</p>

<code>+str  ( adr1 -- adr2 )</code>
    <p>Finds the end of the packed string at adr1</p>


<hr>
<a name="comma"><h1>,</h1></a>

<code>,  ( n -- )</code>
    <p>Places a number in the dictionary</p>

<code>,"  ( -- )    ccc"</code>
    <p>Places a string at the top of the dictionary</p>


<hr>
<a name="minus"><h1>-</h1></a>

<code>-  ( n1 n2 -- n3 )</code>
    <p>Subtracts n1-n2</p>

<code>-rot  ( n1 n2 n3  ---  n3 n1 n2 )</code>
    <p>Shuffles top 3 stack items</p>

<code>-trailing  ( adr +n1  --  adr +n2 )</code>
    <p>Removes trailing spaces</p>


<hr>
<a name="dot"><h1>.</h1></a>

<code>.  ( n  -- )</code>
    <p>Displays a number</p>

<code>."  ( -- )    ccc"</code>
    <p>Compiles a string for later display</p>

<code>.(  ( -- )    ccc)</code>
    <p>Displays a string immediately</p>

<code>.id  ( anf -- )</code>
    <p>Displays the name of a word from its name field address</p>

<code>.name  ( acf -- )</code>
    <p>Displays the name of a word from its compilation address</p>

<code>.r  ( n +n -- )</code>
    <p>Displays a number in a fixed width field</p>

<code>.s  ( -- )</code>
    <p>Displays the contents of the data stack</p>


<hr>
<a name="slash"><h1>/</h1></a>

<code>/  ( n1 n2  --  n3 )</code>
    <p>Divides n1/n2</p>

<code>/c  ( -- n )</code>
    <p>The number of bytes in a byte; 1</p>

<code>/c*  ( n1 -- n2 )</code>
    <p>Multiplies by the size of a byte</p>

<code>/l  ( -- n )</code>
    <p>The number of bytes in a longword; 4 on a 32-bit system</p>

<code>/l*  ( n1 -- n2 )</code>
    <p>Multiply by the size of a longword</p>

<code>/link  ( -- n )</code>
    <p>The number of bytes in a dictionary link; 4 on a 32-bit system</p>

<code>/mod  ( n1 n2  --  n3 n4 )</code>
    <p>n3 is remainder, n4 is quotient of n1/n2</p>

<code>/n  ( -- n )</code>
    <p>The number of bytes in a normal; 4 on a 32-bit system</p>

<code>/n*  ( n1 -- n2 )</code>
    <p>Multiplies by the size of a stack item</p>

<code>/token  ( -- n )</code>
    <p>The number of bytes in a compiled address; 4 on a 32-bit system</p>

<code>/w  ( -- n )</code>
    <p>The number of bytes in a 16-bit word; 2</p>

<code>/w*  ( n1 -- n2 )</code>
    <p>Multiply by the size of a word</p>


<hr>
<a name="digit"><h1>0123456789</h1></a>

<code>0&lt;  ( n  --  flag )</code>
    <p>Is n &lt; 0 ?</p>

<code>0=  ( n  --  flag )</code>
    <p>Is n = 0 ?</p>

<code>0&gt;  ( n  --  flag )</code>
    <p>Is n &gt; 0 ?</p>

<code>1+  ( n1  --  n2 )</code>
    <p>Add 1</p>

<code>1-  ( n1  --  n2 )</code>
    <p>Subtracts 1</p>

<code>16-bit  ( -- )</code>
    <p>Noop on a 16-bit system, aborts on a 32-bit system</p>

<code>16\  ( -- )</code>
    <p>Ignores rest of line if not a 16-bit system</p>

<code>2!  ( n1 n2 adr -- )</code>
    <p>Stores 2 numbers at adr</p>

<code>2*  ( n1 -- n2 )</code>
    <p>Multiplies by 2</p>

<code>2+  ( n1 -- n2 )</code>
    <p>Adds 2</p>

<code>2-  ( n1 -- n2 )</code>
    <p>Subtracts 2</p>

<code>2/  ( n1 -- n2 )</code>
    <p>Divides by 2</p>

<code>2@  ( adr -- n1 n2 )</code>
    <p>Fetchs 2 numbers from adr</p>

<code>2drop  ( n1 n2  -- )</code>
    <p>Removes 2 numbers from stack</p>

<code>2dup  ( n1 n2 --  n1 n2  n1 n2 )</code>
    <p>Duplicates 2 numbers</p>

<code>32-bit  ( -- )</code>
    <p>Aborts if the Forth system is a 16-bit implementation</p>

<code>32\  ( -- )</code>
    <p>Ignores rest of line in a 16-bit system; no-op on a 32-bit system</p>


<hr>
<a name="colon"><h1>:</h1></a>

<code>:  ( -- sys )    name</code>
    <p>Starts the compilation of a new colon definition</p>

<code>;  ( -- )</code>
    <p>Finishes the compilation of a colon definition</p>

<code>;s  ( -- )</code>
    <p>Terminates the loading of the current input file</p>


<hr>
<a name="lessthan"><h1>&lt;</h1></a>

<code>&lt;  ( n1 n2  --  flag )</code>
    <p>Is n1 &lt; n2 ?</p>

<code>&lt;#  ( -- )</code>
    <p>Initializes pictured numeric output</p>

<code>&lt;&lt;  ( n1 cnt -- n2 )</code>
    <p>Left shifts n1 by count places</p>

<code>&lt;=  ( n1 n2  --  flag )</code>
    <p>True if n1 is less than or equal to n2</p>

<code>&lt;&gt;  ( n1 n2  --  flag )</code>
    <p>True if n1 is not equal to n2</p>

<code>&lt;mark  ( -- adr )</code>
    <p>Remembers target of backward branch</p>

<code>&lt;resolve  ( adr -- )</code>
    <p>Finishes a backward branch</p>

<code>&lt;w@  ( adr -- n )</code>
    <p>Fetchs the signed 16-bit word at addr</p>


<hr>
<a name="equals"><h1>=</h1></a>

<code>=  ( n1 n2  --  flag )</code>
    <p>Is n1 = n2 ?</p>

<hr>
<a name="to&gt;&lt;H1">&gt;</a>

<code>&gt;  ( n1 n2  --  flag )</code>
    <p>Is n1 &gt; n2 ?</p>

<code>&gt;=  ( n1 n2  -- flag )</code>
    <p>True if n1 is greater than or equal to n2</p>

<code>&gt;&gt;  ( n1 cnt -- n2 )</code>
    <p>Rights shift n1 by "cnt" places</p>

<code>&gt;&gt;a  ( n1 cnt -- n2 )</code>
    <p>Arithmetic rights shift n1 by "cnt" places (sign bit copied to high bits)</p>

<code>&gt;body  ( acf -- apf )</code>
    <p>Finds the parameter field address from the compilation address</p>

<code>&gt;data  ( acf -- adr )</code>
    <p>Finds the data storage address for the word at acf</p>

<code>&gt;in  ( -- adr )</code>
    <p>Variable containing input stream offset; Implemented in BLOCK.FTH</p>

<code>&gt;link  ( acf -- alf )</code>
    <p>Finds link field address from compilation address</p>

<code>&gt;mark  ( -- adr )</code>
    <p>Remembers the location of forward branch</p>

<code>&gt;name  ( acf -- anf )</code>
    <p>Finds name field address from compilation address</p>

<code>&gt;r  ( n -- )</code>
    <p>Moves a number to the return stack</p>

<code>&gt;relbit  ( adr -- byte-adr bitmask )</code>
    <p>Returns byte address and mask of the relocation bit for the addess "adr"</p>

<code>&gt;resolve  ( adr -- )</code>
    <p>Finishes a forward branch</p>

<code>&gt;type  ( adr +n -- )</code>
    <p>Displays characters and stores them at PAD</p>

<code>&gt;user  ( apf -- user-var-adr )</code>
    <p>Finds a user number that is in the parameter field</p>

<code>&gt;user#  ( acf -- user# )</code>
    <p>Finds the user number associated with the word if there is one</p>


<hr>
<a name="question"><h1>?</h1></a>

<code>?  ( adr  -- )</code>
    <p>Displays the contents of a variable</p>

<code>?branch  ( flag -- )</code>
    <p>High-level conditional branch</p>

<code>?comp  ( -- )</code>
    <p>Aborts if not compiling</p>

<code>?cr  ( -- )</code>
    <p>New line if fewer than no space left on this one</p>

<code>?csp  ( -- )</code>
    <p>Checks stack pointer against value saved by !CSP</p>

<code>?do  ( w1 w2 -- )</code>
    <p>Begins a ?DO .. LOOP to be executed 0 or more times</p>

<code>?dup  ( n  --  n n )</code>
    <p>Duplicates n if it is non-zero</p>

<code>?exec  ( -- )</code>
    <p>Aborts if not interpreting</p>

<code>?leave  ( flag -- )</code>
    <p>Exits from a DO .. LOOP if flag is nonzero</p>

<code>?line  ( n -- )</code>
    <p>New line if fewer than n spaces left on this one</p>

<code>?pairs  ( n1 n2 -- )</code>
    <p>Aborts if n1 is not equal to n2</p>

<code>?stack  ( -- )</code>
    <p>Aborts if the stack pointer is out of range</p>


<hr>
<a name="fetch"><h1>@</h1></a>

<code>@  ( adr  --  n )</code>
    <p>Fetches a number from adr</p>

<hr>
<a name="a"><h1>a</h1></a>

<code>abort  ( -- )</code>
    <p>Aborts current execution and interprets keyboard commands</p>

<code>abort"  ( flag -- )    ccc"</code>
    <p>Conditional abort with message</p>

<code>abs  ( n -- u )</code>
    <p>Absolute value</p>

<code>alias  ( -- )    new-name existing-name</code>
    <p>Creates a new name for an existing word</p>

<code>align  ( -- )</code>
    <p>Makes sure the dictionary pointer is on a machine word boundary</p>

<code>aligned  ( adr1 -- adr2 )</code>
    <p>Adjusts an address to a machine word boundary</p>

<code>allot  ( n -- )</code>
    <p>Allocates space in the dictionary</p>

<code>and  ( n1 n2 -- n3 )</code>
    <p>Logical and</p>

<code>another?  ( -- [ anf ] more? )</code>
    <p>Selects next word in vocabulary</p>

<code>ascii  ( -- char )    ccc</code>
    <p>Numerical value of first ascii character of next word</p>


<hr>
<a name="b"><h1>b</h1></a>

<code>base  ( --  adr )</code>
    <p>Variable containing number base</p>

<code>begin  ( -- )</code>
    <p>Begins a BEGIN .. WHILE .. REPEAT loop</p>

<code>between  ( n min max -- f )</code>
    <p>True if min &lt;= n &lt;= max</p>

<code>bl  ( -- n )</code>
    <p>The ascii code for the space character; decimal 32</p>

<code>blk  ( -- adr )</code>
    <p>Variable containing input block number; Implemented in BLOCK.FTH</p>

<code>body&gt;  ( apf -- acf )</code>
    <p>Finds compilation address from parameter field address</p>

<code>bounds  ( adr1 len -- adr2 adr1 )</code>
    <p>Converts address and length to endadr startadr</p>

<code>branch  ( -- )</code>
    <p>High-level unconditional branch</p>

<code>bwjoin  ( b.low b.high -- w )</code>
    <p>Joins two bytes to form a 16-bit number</p>

<code>bye  ( -- )</code>
    <p>Exits from Forth</p>


<hr>
<a name="c"><h1>c</h1></a>

<code>c!  ( n -- adr )</code>
    <p>Stores a byte at adr</p>

<code>c@  ( adr -- n )</code>
    <p>Fetches a byte from adr</p>

<code>ca+  ( adr1 index -- adr2 )</code>
    <p>Increments adr1 by index times the size of a byte</p>

<code>ca1+  ( adr1 -- adr2 )</code>
    <p>Increments adr1 by the size of a byte</p>

<code>canonical  ( adr -- adr )</code>
    <p>Converts a string to lower case</p>

<code>caps  ( -- adr )</code>
    <p>USER variable controlling upper case/lower case sensitivity</p>

<code>case  ( selector -- selector )</code>
    <p>Begins a CASE ... ENDCASE conditional</p>

<code>catch ( acf -- 0|error )</code>
    <p>Executes 'acf'.  Returns 0 if no THROW occurred, else returns error code.</p>

<code>ccall  ( args ... format call# -- [ result ] )</code>
    <p>Executes user C function "call#", passing args according to "format" string</p>

<code>ccall:  ( table-entry# -- )  name   { arg-spec arg-spec ... -- result-spec }</code>
    <p>Creates a forth word to execute a user-supplied C function</p>

<code>cmove  ( adr1 adr2 u -- )</code>
    <p>Copies u bytes from adr1 to adr2</p>

<code>cmove&gt;  ( adr1 adr2 u -- )</code>
    <p>Copies u bytes from adr1 to adr2</p>

<code>code  ( -- sys )    name</code>
    <p>Starts the definition of an assembly language word</p>

<code>compile  ( -- )</code>
    <p>Compiles next word at run time</p>

<code>constant  ( n -- )    name</code>
    <p>Defines a constant</p>

<code>context  ( -- adr )</code>
    <p>Array of vocabularies to search</p>

<code>control  ( -- char )    ccc</code>
    <p>Control character number of first character of next word</p>

<code>convert  ( +l1 adr1  --  +l2 adr2 )</code>
    <p>Converts a string to a number</p>

<code>count  ( adr1 --  adr2 +n )</code>
    <p>Unpacks a packed string</p>

<code>cr  ( -- )</code>
    <p>Terminates a line on the display and goes to the next line</p>

<code>crash  ( -- )</code>
    <p>Initial action for words defined by DEFER</p>

<code>create  ( -- )    name</code>
    <p>Generic defining word</p>

<code>current  ( -- adr )</code>
    <p>Variable containing compilation vocabulary</p>


<hr>
<a name="d"><h1>d</h1></a>

<code>decimal  ( -- )</code>
    <p>Set number base to 10</p>

<code>defer  ( -- )    name</code>
    <p>Defining word for forward references or execution vectors</p>

<code>definer  ( acf -- definer-acf )</code>
    <p>Finds the word which defined the word at acf</p>

<code>definitions  ( -- )</code>
    <p>Sets compilation vocabulary</p>

<code>delimiter  ( -- adr )</code>
    <p>USER variable containing the actual delimiter found by WORD</p>

<code>depth  ( -- +n )</code>
    <p>How many numbers on stack?</p>

<code>digit  ( char base -- digit true | char false )</code>
    <p>Converts a character to a digit</p>

<code>do  ( n1 n2 -- )</code>
    <p>Begins a DO .. LOOP</p>

<code>do-defined  ( cfa immediate? -- ?? )</code>
    <p>Called to handle a predefined word during interpreting or compilation</p>

<code>do-literal  ( l -- ?? )</code>
    <p>Called to handle number during interpreting or compilation</p>

<code>do-undefined  ( str -- )</code>
    <p>Called to handle an undefined word during interpreting or compilation</p>

<code>does&gt;  ( -- adr )</code>
    <p>Starts the run-time clause for defining words</p>

<code>dpl  ( -- adr )</code>
    <p>Variable containing the position of the decimal point in last number input</p>

<code>drop  ( n -- )</code>
    <p>Removes n from the stack</p>

<code>du  ( adr -- adr+64 )</code>
    <p>Displays 64 bytes of memory starting at adr</p>

<code>dump  ( adr len -- )</code>
    <p>Displays len bytes of memory starting at adr</p>

<code>dup  ( n -- n n )</code>
    <p>Duplicates n.</p>


<hr>
<a name="e"><h1>e</h1></a>

<code>else  ( -- )</code>
    <p>Executes the following code if IF failed</p>

<code>emit  ( char -- )</code>
    <p>Displays the character</p>

<code>end-string-array  ( -- )</code>
    <p>Finishes the definition of a string array</p>

<code>endcase  ( selector -- )</code>
    <p>Terminates a CASE ... ENDCASE conditional</p>

<code>endof  ( -- )</code>
    <p>Terminates an OF ... ENDOF clause within a CASE ... ENDCASE conditional</p>

<code>entry  ( -- adr )</code>
    <p>USER variable used to implement multitasking</p>

<code>erase  ( adr u -- )</code>
    <p>Sets u bytes of memory to 0</p>

<code>errno  ( -- adr )</code>
    <p>USER variable containing the last system error code</p>

<code>error-output  ( -- )</code>
    <p>Selects the error output stream</p>

<code>execute  ( acf -- )</code>
    <p>Executes the word whose compilation address is on the stack</p>

<code>exit  ( -- )</code>
    <p>Returns from the current word</p>

<code>expect  ( adr +n -- )</code>
    <p>Gets a line of input from the keyboard and stores it at adr</p>


<hr>
<a name="f"><h1>f</h1></a>

<code>false  ( -- 0 )</code>
    <p>The value FALSE, which is 0</p>

<code>fclose  ( fd -- )</code>
    <p>Closes the file whose descriptor is "fd"</p>

<code>fcr  ( fd -- )</code>
    <p>Writes the end-of-line sequence to the file "fd"</p>

<code>fexit  ( -- )</code>
    <p>Ignores the rest of the current input file</p>

<code>fflush  ( fd -- )</code>
    <p>Forces file buffers to be written to the file.</p>

<code>fgetc  ( fd -- char )</code>
    <p>Returns next character from file whose descriptor is "fd", or -1 at end.</p>

<code>fgetline  ( adr fd -- #bytes )</code>
    <p>Reads next line from file "fd" into buf at "adr" as packed string.</p>

<code>fgets  ( adr maxlen fd -- #bytes-read )</code>
    <p>Reads up to "maxlen" characters from file "fd" into buffer at "adr".</p>

<code>fill  ( adr u byte  -- )</code>
    <p>Sets u bytes of memory to byte</p>

<code>find  ( adr1 -- adr2 n )</code>
    <p>Finds a word in the dictionary</p>

<code>fload  ( -- )    filename</code>
    <p>Interprets a file</p>

<code>follow  ( threads -- )</code>
    <p>Prepares to scan a vocabulary; see ANOTHER?</p>

<code>fopen  ( string mode -- fd )</code>
    <p>Opens the file "string" in mode "mode" (READ, WRITE, MODIFY).</p>

<code>forth  ( -- )</code>
    <p>The main vocabulary</p>

<code>forth-83  ( -- )</code>
    <p>Asserts the dialect</p>

<code>fputc  ( char fd -- )</code>
    <p>Writes the character "char" to the file whose descriptor is "fd"</p>

<code>fputs  ( adr len fd -- )</code>
    <p>Writes "len" characters from the buffer at "adr" to the file "fd"</p>

<code>fseek  ( l.position fd -- )</code>
    <p>Sets position of file "fd" to the 32-bit number "l.position"</p>

<code>fsize  ( fd -- l.size )</code>
    <p>Returns 32-bit size of the file "fd"</p>

<code>ftell  ( fd -- l.position )</code>
    <p>Returns 32-bit current position within the file "fd"</p>

<code>fungetc  ( char fd -- )</code>
    <p>Puts "char" back on file "fd"; undoes "fgetc"</p>

<hr>
<a name="g"><h1>g</h1></a>


<hr>
<a name="h"><h1>h</h1></a>

<code>here  ( -- adr )</code>
    <p>Address of top of dictionary</p>

<code>hex  ( -- )</code>
    <p>Sets the number base to 16</p>

<code>hidden  ( -- )</code>
    <p>Vocabulary containing words used only to implement other words</p>

<code>hide  ( -- )</code>
    <p>Makes the most recent word invisible</p>

<code>hold  ( char  -- )</code>
    <p>Inserts the char in the pictured numeric output string</p>


<hr>
<a name="i"><h1>i</h1></a>

<code>i  ( -- n )</code>
    <p>Loop index</p>

<code>if  ( flag -- )</code>
    <p>Executes following code if flag is true</p>

<code>immediate  ( -- )</code>
    <p>Marks the last word as immediate</p>

<code>immediate?  ( acf -- flag )</code>
    <p>True if word is immediate</p>

<code>input-file-name  ( -- str )</code>
    <p>The name of the file being interpreted.</p>

<code>interpret  ( -- )</code>
    <p>Interprets the input stream</p>

<code>is  ( action-acf -- )    name</code>
    <p>Installs a new action in a DEFER word</p>


<hr>
<a name="j"><h1>j</h1></a>

<code>j  ( -- n )</code>
    <p>Loop index for next enclosing loop</p>

<hr>
<a name="k"><h1>k</h1></a>

<code>key  ( -- char )</code>
    <p>Explicit 32-bit addition</p>

<hr>
<a name="l"><h1>l</h1></a>

<code>l+!  ( l adr  -- )</code>
    <p>Adds l to the 32-bit number at adr</p>

<code>l,  ( l -- )</code>
    <p>Places a longword in the dictionary</p>

<code>l-&gt;n  ( l -- n )</code>
    <p>Converts a longword to a stack item; noop on this system</p>

<code>l.  ( l -- )</code>
    <p>Displays a 32-bit signed number</p>

<code>l0=  ( l  --  flag )</code>
    <p>True if l is zero</p>

<code>l&lt;  ( l1 l2  --  flag )</code>
    <p>True if l1 is less than l2</p>

<code>l=  ( l1 l2 -- flag )</code>
    <p>True if l1 is equal to l2</p>

<code>l&gt;=  ( l1 l2 -- flag )</code>
    <p>True if l1 is less than l2; explicitly 32-bit</p>

<code>l&gt;name  ( alf -- anf )</code>
    <p>Finds the name field address from link field address</p>

<code>l&gt;r  ( l -- )</code>
    <p>Moves a longword to the return stack</p>

<code>l@  ( adr -- l )</code>
    <p>Fetchs the 32-bit longword at adr</p>

<code>la+  ( adr1 index -- adr2 )</code>
    <p>Increments adr1 by index times the size of a longword</p>

<code>la1+  ( adr1 -- adr2 )</code>
    <p>Increments adr1 by the size of a longword</p>

<code>land  ( l1 l2 -- l3 )</code>
    <p>Explicit 32-bit logical and</p>

<code>last  ( -- adr )</code>
    <p>USER variable containing the name field address of the last word created</p>

<code>lastacf  ( -- acf )</code>
    <p>The compilation address of the last word created</p>

<code>lbetween  ( l1 lmin lmax -- flag )</code>
    <p>True if lmin &lt;= l1 &lt;= lmax; explicitly 32-bit</p>

<code>lbsplit  ( l -- b.low b.mlow b.mhigh b.high )</code>
    <p>Splits a longword into four bytes</p>

<code>lconstant  ( l -- )    name</code>
    <p>Defines a 32-bit constant</p>

<code>ldrop  ( l -- )</code>
    <p>Removes a longword from the stack</p>

<code>ldup  ( l -- l l )</code>
    <p>Duplicates l</p>

<code>leave  ( -- )</code>
    <p>Exit from DO .. LOOP</p>

<code>link!  ( link adr -- )</code>
    <p>Stores a dictionary link</p>

<code>link@  ( lfa -- link )</code>
    <p>Fetches a dictionary link</p>

<code>literal  ( -- n )</code>
    <p>Compiles a number</p>

<code>literal?  ( str -- str false | n true )</code>
    <p>Checks to see if a string is a number during interpreting or compilation</p>

<code>lliteral  ( -- l )</code>
    <p>Compiles an explicit 32-bit number</p>

<code>lmargin  ( -- adr )</code>
    <p>Variable containg left margin for output formatting</p>

<code>lnegate  ( l1 -- l2 )</code>
    <p>Explicit 32-bit negation</p>

<code>lnover  ( l1 n -- l1 n l2 )</code>
    <p>Copies a longword over a normal</p>

<code>lnswap  ( l n -- n l )</code>
    <p>Swaps a longword and a normal</p>

<code>long?  ( -- flag )</code>
    <p>True if the number that was just input contained a decimal point</p>

<code>loop  ( -- )</code>
    <p>End of DO .. LOOP</p>

<code>lose  ( -- )</code>
    <p>Compiled in place of an undefined word; aborts</p>

<code>lr&gt;  ( -- l )</code>
    <p>Moves a longword from the return stack</p>

<code>lswap  ( l1 l2 -- l2 l1 )</code>
    <p>Swap 2 longwords</p>

<code>lvariable  ( -- )    name</code>
    <p>Define a 32-bit variable</p>

<code>lwithin  ( l1 lmin lmax -- flag )</code>
    <p>True if lmin &lt;= l1 &lt; lmax; explicitly 32-bit</p>

<code>lwsplit  ( l -- w.low w.high )</code>
    <p>Split a longword into two words</p>


<hr>
<a name="m"><h1>m</h1></a>

<code>max  ( n1 n2  --  n3 )</code>
    <p>n3 is maximum of n1 and n2</p>

<code>maxdp  ( -- adr )</code>
    <p>The highest address that the dictionary can grow to</p>

<code>maxprimitive  ( -- n )</code>
    <p>The maximum number of Forth words implemented directly in C</p>

<code>min  ( n1 n2  --  n3 )</code>
    <p>n3 is minimum of n1 and n2</p>

<code>mod  ( n1 n2  -- n3 )</code>
    <p>Remainder of n1/n2</p>

<code>move  ( adr1 adr2 u -- )</code>
    <p>Copies u bytes from adr1 to adr2</p>

<code>mu/mod  ( ul n -- n.rem ul.quot )</code>
    <p>Divides longword by normal giving normal remainder and long quotient</p>

<hr>
<a name="n"><h1>n</h1></a>

<code>n-&gt;l  ( u -- l )</code>
    <p>Converts a stack item to a longword; noop on this system</p>

<code>n-&gt;w  ( n -- w )</code>
    <p>Converts a stack item to a word</p>

<code>n&gt;link  ( anf -- alf )</code>
    <p>Finds link field from name field</p>

<code>na+  ( adr1 index -- adr2 )</code>
    <p>Increments adr1 by index times the size of a stack item</p>

<code>na1+  ( adr1 -- adr2 )</code>
    <p>Increments adr1 by the size of a stack item</p>

<code>name-&gt;string  ( anf -- str )</code>
    <p>Converts the name of a Forth word to a packed string</p>

<code>name&gt;  ( anf -- acf )</code>
    <p>Finds compilation address from name field</p>

<code>negate  ( n1 -- n2 )</code>
    <p>Changes the sign of n1</p>

<code>newline  ( -- char )</code>
    <p>The character which ends a line in a text file.</p>

<code>nip  ( n1 n2 -- n2 )</code>
    <p>Discards the second element from the data stack</p>

<code>nlover  ( n1 l -- n1 l n2 )</code>
    <p>Copies a normal over a longword</p>

<code>nlswap  ( n l -- l n )</code>
    <p>Swaps a normal and a longword</p>

<code>noop  ( -- )</code>
    <p>Does nothing</p>

<code>not  ( n1 -- n2 )</code>
    <p>One's complement</p>

<code>number?  ( adr -- l flag )</code>
    <p>Converts a character string to a 32-bit number</p>

<code>nuser  ( -- )    name</code>
    <p>Defines and allocates space for a User variable</p>

<hr>
<a name="o"><h1>o</h1></a>

<code>of  ( selector test-value -- )</code>
    <p>Begins an OF ... ENDOF clause within a CASE ... ENDCASE conditional</p>

<code>off  ( adr  -- )</code>
    <p>Stores false at adr</p>

<code>on  ( adr  -- )</code>
    <p>Stores true at adr</p>

<code>or  ( n1 n2 -- n3 )</code>
    <p>Logical or</p>

<code>origin  ( -- adr )</code>
    <p>The address of the start of the Forth system</p>

<code>over  ( n1 n2  --  n1 n2 n3 )</code>
    <p>n3 is a copy of n1.</p>

<hr>
<a name="p"><h1>p</h1></a>

<code>pack  ( adr1 len adr2 -- adr2 )</code>
    <p>Makes a packed string from adr1 len, placing it at adr2</p>

<code>pad  ( --  adr )</code>
    <p>The address of a scratch area used to temporary storage</p>

<code>pick  ( n1  --  n2 )</code>
    <p>Copies n-th number</p>

<code>place  ( adr1 len adr2 -- )</code>
    <p>Makes a packed string from adr1 len, placing it at adr2</p>

<code>primitive?  ( acf -- flag )</code>
    <p>True if acf is a reference to a Forth word implemented directly in C</p>

<code>printable?  ( char -- flag )</code>
    <p>True if character is printable</p>


<hr>
<a name="q"><h1>q</h1></a>

<code>quit  ( -- )</code>
    <p>Interprets keyboard commands</p>


<hr>
<a name="r"><h1>r</h1></a>

<code>r&gt;  ( -- n )</code>
    <p>Moves a number from the return stack to the data stack</p>

<code>r@  ( -- n )</code>
    <p>Copies the top of the return stack to the data stack</p>

<code>repeat  ( -- )</code>
    <p>Ends a BEGIN .. WHILE .. REPEAT loop</p>

<code>restore-output  ( -- )</code>
    <p>Goes back to the old output stream after ERROR-OUTPUT</p>

<code>reveal  ( -- )</code>
    <p>Makes the most recent word visible</p>

<code>rmargin  ( -- adr )</code>
    <p>Variable containg right margin for output formatting</p>

<code>root  ( -- )</code>
    <p>The vocabulary selected by ONLY</p>

<code>rot  ( n1 n2 n3  ---  n2 n3 n1 )</code>
    <p>Rotates 3 numbers</p>

<code>rp!  ( adr -- )</code>
    <p>Changes the return stack pointer</p>

<code>rp0  ( -- adr )</code>
    <p>A variable containing the address of the bottom of the return stack</p>

<code>rp@  ( -- adr )</code>
    <p>The address of the top of the return stack</p>

<hr>
<a name="s"><h1>s</h1></a>

<code>s-&gt;l  ( n -- l )</code>
    <p>Converts a signed stack item to a longword; noop on this system</p>

<code>s.  ( n -- )</code>
    <p>Displays n as a signed number</p>

<code>save-forth  ( filename -- )</code>
    <p>Writes the Forth dictionary to a file.</p>

<code>see  ( -- )    name</code>
    <p>Decompiles the named word</p>

<code>shift  ( n1 n2 -- n3 )</code>
    <p>Sets sign of pictured output</p>

<code>skipstr  ( -- adr len )</code>
    <p>Used to implement words with in-line strings</p>

<code>sp!  ( adr -- )</code>
    <p>Changes the data stack pointer</p>

<code>sp0  ( --  ADDR )</code>
    <p>Variable containing the address of the bottom of the Data Stack</p>

<code>sp@  ( -- adr )</code>
    <p>The address of the top of the data stack</p>

<code>space  ( -- )</code>
    <p>Displays a space character</p>

<code>spaces  ( +n  -- )</code>
    <p>Displays n spaces</p>

<code>span  ( -- adr )</code>
    <p>Variable containing the number of characters read by EXPECT</p>

<code>state  ( -- adr )</code>
    <p>Variable that is nonzero in compile state</p>

<code>string-array  ( -- )     name</code>
    <p>Begins the definition of a string array</p>

<code>swap  ( n1 n2  --  n2 n1 )</code>
    <p>Exchanges the top 2 stack entries.</p>

<code>syscall  ( args ... format sycall# -- error? )</code>
    <p>Executes system call "syscall#", passing args according to "format" string</p>

<hr>
<a name="t"><h1>t</h1></a>

<code>ta+  ( adr1 index -- adr2 )</code>
    <p>Increments adr1 by index times the size of a compiled address</p>

<code>ta1+  ( adr1 -- adr2 )</code>
    <p>Increments adr1 by the size of a compiled address</p>

<code>td  ( -- ? )</code>
    <p>Interprets the next word or number in DECIMAL mode</p>

<code>th  ( -- ? )</code>
    <p>Interprets the next word or number in HEX mode</p>

<code>then  ( -- )</code>
    <p>Terminates an IF ... ELSE ... THEN</p>

<code>throw  ( error -- )</code>
    <p>Aborts back to most recent CATCH point.  See CATCH.</p>

<code>tib  ( -- adr )</code>
    <p>The address of the Text Input Buffer</p>

<code>to-column  ( column -- )</code>
    <p>Advances the output to the indicated column</p>

<code>token!  ( adr2 adr1 -- )</code>
    <p>Stores a relocatable address at adr1</p>

<code>token,  ( adr -- )</code>
    <p>Places a relocatable address in the dictionary</p>

<code>token@  ( adr1 -- adr2 )</code>
    <p>Fetches a relocatable address</p>

<code>true  ( -- -1 )</code>
    <p>The value TRUE , which is -1</p>

<code>tuck  ( n1 n2 -- n2 n1 n2 )</code>
    <p>Copies the top of the stack underneath the second item</p>

<code>type  ( adr +n -- )</code>
    <p>Displays n characters</p>

<hr>
<a name="u"><h1>u</h1></a>

<code>u.  ( u -- )</code>
    <p>Displays an unsigned number</p>

<code>u.r  ( u +n -- )</code>
    <p>Prints an unsigned number in fixed width field</p>

<code>u&lt;  ( u1 u2  --  flag )</code>
    <p>Unsigned version of &lt; .</p>

<code>u&lt;=  ( u1 n2 -- flag )</code>
    <p>True if u1 is less than or equal to u2</p>

<code>u&gt;  ( u1 n2 -- flag )</code>
    <p>True if u1 is greater than u2</p>

<code>u&gt;=  ( u1 n2 -- flag )</code>
    <p>True if u1 is greater than or equal to u2</p>

<code>ualloc  ( size -- new-user-number )</code>
    <p>Allocates space in the user area</p>

<code>ul*  ( ul1 ul2 -- lproduct )</code>
    <p>Unsigned 32x32 -&gt; 32 multiply</p>

<code>um*  ( uw1 uw2 -- ul )</code>
    <p>16 bits times 16 bits unsigned multiply</p>

<code>um/mod  ( ul un -- un.rem un.quot )</code>
    <p>Divide unsigned 32-bit number by unsigned number</p>

<code>unnest  ( -- )</code>
    <p>Returns from a colon definition</p>

<code>until  ( flag -- )</code>
    <p>Continues executing a BEGIN .. UNTIL loop until flag is true</p>

<code>up!  ( adr -- )</code>
    <p>Changes the starting address of the user area</p>

<code>up0  ( -- adr )</code>
    <p>User variable containing the starting address of the USER area</p>

<code>up@  ( --  adr )</code>
    <p>The starting address of the aser area</p>

<code>user  ( offset -- )    name</code>
    <p>Defines a variable at the given offset in the User area</p>

<code>user-size  ( -- n )</code>
    <p>The size in bytes of the USER area.</p>

<hr>
<a name="v"><h1>v</h1></a>

<code>variable  ( -- )    name</code>
    <p>Defines a variable</p>

<code>vfind  ( str voc-ptr -- cfa 1 )</code>
    <p>Searches for a word in a single vocabulary</p>

<code>voc-link  ( -- adr )</code>
    <p>USER variable containing the address of the last vocabulary created</p>

<code>vocabulary  ( -- )    name</code>
    <p>Defines a new vocabulary</p>


<hr>
<a name="w"><h1>w</h1></a>

<code>w!  ( w adr -- )</code>
    <p>Stores a 16-bit word at adr</p>

<code>w,  ( w -- )</code>
    <p>Places a word in the dictionary</p>

<code>w-&gt;l  ( uw -- l )</code>
    <p>Converts an unsigned 16-bit number to a 32-bit number</p>

<code>w@  ( adr -- w )</code>
    <p>Fetches the unsigned word at adr</p>

<code>wa+  ( adr1 index -- adr2 )</code>
    <p>Increments adr1 by index times the size of a word</p>

<code>wa1+  ( adr1 -- adr2 )</code>
    <p>Increments adr1 by the size of a word</p>

<code>warning  ( -- adr )</code>
    <p>USER variable controlling "isn't Unique" messages</p>

<code>wbsplit  ( w -- b.low b.high )</code>
    <p>Split a 16-bit number into two bytes</p>

<code>where  ( -- )</code>
    <p>Prints a message telling where in the input stream you are</p>

<code>while  ( flag  -- )</code>
    <p>Continues execution of BEGIN .. WHILE .. REPEAT loop while flag is true</p>

<code>why  ( -- )</code>
    <p>Tells why the last failing system command failed</p>

<code>within  ( n min max -- f )</code>
    <p>True if n &lt;= x &lt; max</p>

<code>wljoin  ( w.low w.high -- l )</code>
    <p>Joins two words to form a longword</p>

<code>word  ( char -- adr )</code>
    <p>Collects a char-delimited string from the input stream</p>

<code>words  ( -- )</code>
    <p>Displays the words in the context vocabulary</p>

<hr>
<a name="x"><h1>x</h1></a>

<code>xor  ( n1 n2 -- n3 )</code>
    <p>Exclusive or</p>

<hr>
<a name="y"><h1>y</h1></a>

<hr>
<a name="z"><h1>z</h1></a>

<hr>
<a name="bracket"><h1>[</h1></a>

<code>[  ( -- )</code>
    <p>Begins interpreting</p>

<code>[""]  ( -- )    ccc</code>
    <p>Collects a word from the input stream and compiles it as a string</p>

<code>[']  ( -- adr )</code>
    <p>Compiles the compilation address of a word</p>

<code>[compile]  ( -- )</code>
    <p>Compiles the next word even if it's immediate</p>

<hr>
<a name="backslash"><h1>\</h1></a>

<code>\  ( -- )    rest-of-line</code>
    <p>Skips the rest of the line</p>

<code>\c  ( -- )    rest-of-line</code>
    <p>Skips the rest of the line</p>

<code>\dtc  ( -- )</code>
    <p>Does nothing</p>

<code>\itc  ( -- )</code>
    <p>Ignores the rest of the line</p>

<code>\needs  ( -- )    name rest-of-line</code>
    <p>Interprets the rest of the line if needed-word is not already defined</p>

<code>\t16  ( -- )</code>
    <p>Ignores the rest of the line</p>

<code>\t32  ( -- )</code>
    <p>Does nothing</p>

<hr>
<a name="rbracket"><code>]</code></a>

<code>]  ( -- )</code>
    <p>Begins compilation</p>

<hr>
<a name="caret"><h1>^</h1></a>

<hr>
<a name="curly"><h1>{</h1></a>


<hr>
<a name="floatingpointwords"><h1>Floating Point Words</h1></a>

<h3>C Forth 83 Floating Point</h3>

The C Forth 83 Floating Point interface is intended to conform to the
Forth Vendors Group proposed Forth Floating Point Standard.

This implementation has the following characteristics:

* Floating point numbers are kept on a separate floating point stack.
* The floating point format is whatever the C floating point implementation
  uses for double precision floating point.

Floating point numeric input:

    Floating point numbers are of the form, for example:
	+1234.5678E-6

    The "E" is mandatory; it allows the Forth number parser to
    distinguish this as a floating point number.  Examples:

    	1E0   -1.3E-4

    The presence of a decimal point is not in itself sufficient to
    distinguish a number as being floating point.  The "E" must be
    present.

    Floating point numbers are only recognized if BASE is decimal.

    Floating point numbers may be both interpreted and compiled in the
    usual way.

Glossary:
	Words marked "FVG" are specified by the Forth Vendors Group
	proposed floating point standard.

<code>F+		fp1 fp2 -- fp3			 	FVG</code>
    <p>Floating-point addition.  fp3 is the sum of fp1 and fp2.</p>

<code>F-		fp1 fp2 -- fp3		 		FVG</code>
    <p>Floating-point subtraction.  fp3 is the difference fp1 minus fp2.</p>

<code>F*		fp1 fp2 -- fp3				FVG</code>
    <p>Floating-point multiplication.  fp3 is the product of fp1 and fp2.</p>

<code>F/		fp1 fp2 -- fp3				FVG</code>
    <p>Floating-point division.  fp3 is the quotient of fp1 divided by fp2.</p>

<code>F**		fp1 fp2 -- fp3				FVG</code>
    <p>Floating-point exponentiation.  fp3 is the value of fp1 raised to the power fp2.</p>

<code>FCOS		fp1 -- fp2				FVG</code>
    <p>fp2 is the cosine of fp1.  Input argument is in radians.</p>

<code>FSIN		fp1 -- fp2				FVG</code>
    <p>fp2 is the sine of fp1.  Input argument is in radians.</p>

<code>FSINCOS		fp1 -- fp2 fp3				FVG</code>
    <p>fp2 is the sine of fp1 and fp3 is the cosine of fp3.  Input argument is in radians.</p>

<code>FTAN		fp1 -- fp2				FVG</code>
    <p>fp2 is the tangent of r1.  The tangent of pi/2 or 3pi/2 radians returns the largest floating point number representable in the implementation's binary format.</p>

<code>FALN		fp1 -- fp2				FVG</code>
    <p>The exponential function.  fp2 is the value of e raised to the power of fp1.</p>

<code>FLN		fp1 -- fp2				FVG</code>
    <p>fp2 is the natural logarithm of fp1.</p>

<code>FSQRT		fp1 -- fp2				FVG</code>
    <p>fp2 is the square root of fp1.</p>

<code>FLOG		fp1 -- fp2				FVG</code>
    <p>fp2 is the base 10 logarithm of fp1.</p>

<code>FATAN		fp1 -- fp2				FVG</code>
    <p>fp2 is the arctangent of fp1.  This operator is valid for all floating point numbers.  The result is in the range -pi/2 to pi/2 radians.</p>

<code>FASIN		fp1 -- fp2				FVG</code>
    <p>fp2 is the arcsine of fp1.  Valid for -1 &lt;= fp1 &lt;= 1.  The result is in the range -pi/2 to pi/2 radians.</p>

<code>FACOS		fp1 -- fp2				FVG</code>
    <p>fp2 is the arccosine of fp1.  Valid for -1 &lt;= fp1 &lt;= 1.  The result is in the range -pi/2 to pi/2 radians.</p>

<code>FSINH		fp1 -- fp2				FVG</code>
    <p>fp2 is the hyperbolic sine of fp1.</p>

<code>FCOSH		fp1 -- fp2				FVG</code>
    <p>fp2 is the hyperbolic cosine of fp1.</p>

<code>FTANH		fp1 -- fp2				FVG</code>
    <p>fp2 is the hyperbolic tangent of fp1.</p>

<code>FVARIABLE 	-- (compilation)			FVG</code>
    <p> -- addr (execution)</p>
    <p>A defining word used in the form:</p>
    <p>FVARIABLE cccc</p>
    <p>When FVARIABLE executes, it creates the definition cccc with its parameter field uninitialized.  When cccc is later executed, the address of the parameter field is left on the stack, so that a F@ or F! operation may access this location.</p>

<code>FCONSTANT 	fp -- (compilation)			FVG</code>
    <p>  -- fp (execution)</p>
    <p>A defining word used in the form:</p>
    <p>fp FCONSTANT &lt;name&gt;</p>
    <p>When FCONSTANT executes, it creates the definition {name} so that when &lt;name&gt; is later executed, the floating point number fp is left on the stack.</p>

<code>FALOG		fp1 -- fp2				FVG</code>
    <p>fp2 is the result of raising 10 to the fp1 power.</p>

<code>F.		fp --					FVG</code>
    <p>Display fp on the currently selected output device in fixed-point form; i.e., the location of the decimal point is adjusted as necessary so that no exponent need be displayed.  The number of digits specified by the most recent execution of the word PLACES are printed to the right of the decimal point.  A trailing blank follows.  For example, 4 PLACES 1.2345E02 F. will display as 123.4500b (where the character "b" denotes an ASCII blank).</p>

<code>F.R		fp n1 n2 --				FVG</code>
    <p>Display fp on the currently selected output device in fixed-point form with n1 digits to the right of the decimal place, right justified in a field of width n.  Numbers that cannot be represented within the given field width are printed in exponential form.</p>
    <p>If the current system base is not decimal, an error condition exists.  For example, 1.2345E2  4  12  F.R  will display as bbbb123.4500 (where the character "b" denotes an ASCII blank).</p>

    <p>** Not implemented **</p>

<code>F.S		--</code>
    <p>Print the contents of the floating point stack without affecting its contents.  The number on the top of the stack appears on the right-hand side of the line.</p>

<code>E.		fp --					FVG</code>
    <p>Display fp in exponential form.  The significand contains the maximum number of significant digits allowed by the floating-point data format, and the exponent is explicitly displayed even if it is zero.  A trailing blank follows.  If the current system base is not decimal, an error condition exists.</p>

<code>E.R		fp n1 n2 --				FVG</code>
    <p>Display fp on the currently selected output device in exponential form with n1 digits to the right of the decimal place, right justified in a field of width n.  If the current system base is not decimal, an error condition exists.  For example, 1.234E0 5  12  E.R  will display as  bb.12340E-01  (where the character "b" denotes an ASCII blank).</p>

    <p>** Not implemented **</p>

<code>FLOAT 		l -- fp					FVG</code>
    <p>Convert a signed long integer into its floating-point equivalent, removing the long integer from the Forth parameter stack and leaving the result on the floating-point stack.</p>

<code>INT		fp -- l					FVG</code>
    <p>Truncate a floating-point number to a signed long integer (round it toward zero), removing the fp number from the floating-point stack and leaving the result on the Forth parameter stack.  Underflow gives a zero result, overflow is an error condition.</p>

<code>FIX		fp -- l					FVG</code>
    <p>Convert a floating-point number to a signed long integer, rounding towards the nearest integer, removing the fp number from the floating-point stack, and leaving the result on the Forth parameter stack.  Underflow gives a zero result, overflow is an error condition.</p>

<code>FABS		fp1 --fp2				FVG</code>
	fp2 is the absolute value of the floating-point number fp1 .

<code>FNEGATE		fp1 -- fp2				FVG</code>
    <p>fp2 is the negative of the floating-point number fp1 .</p>

<code>F!		f addr -- 				FVG</code>
    <p>Store a floating-point number from the floating-point stack into the address that is on top of the Forth parameter stack.</p>
	
<code>F@		addr -- f				FVG</code>
    <p>Fetch a floating-point number to the top of the floating-point stack from the address that is on top of the Forth parameter stack.</p>

<code>FDROP		fp --					FVG</code>
    <p>Discard floating-point number on top of the stack.</p>

<code>FSWAP		fp1 fp2 -- fp2 fp1			FVG</code>
    <p>Interchange the two floating-point numbers on top of the stack.</p>

<code>FOVER		fp1 fp2 -- fp1 fp2 fp1			FVG</code>
    <p>Copy the second floating-point number on the stack to the top of the stack.</p>

<code>FDUP		fp -- fp fp				FVG</code>
    <p>Duplicate the floating-point number on top of the stack.</p>

<code>FROT		fp1 fp2 fp3 -- fp2 fp3 fp1		FVG</code>
    <p>Rotate the third floating-point number to the top of the stack.</p>

<code>FPOP		f -- l l</code>
    <p>Move the fp number on top of the floating-point stack to the top two cells of the parameter stack, without converting it to an integer.  fpop just moves the bits, without any sort of format conversion.</p>

<code>FPUSH		l l -- f</code>
    <p>Push the top two numbers on the parameter stack to the top cell of the floating-point stack, without converting them to fp.</p>
    <p>fpop just moves the bits, without any sort of format conversion.</p>

<code>F0=		fp -- f					FVG</code>
    <p>True if the floating-point number on top of the stack is equal to zero.  The fp number is removed from the floating-point stack, and the flag is left on top of the Forth parameter stack.</p>

<code>F0&lt;&gt;		fp -- f</code>
    <p>True if the floating-point number on top of the stack is not equal to zero.  The fp number is removed from the floating-point stack, and the flag is left on top of the Forth parameter stack.</p>

<code>F0&lt;		fp -- f					FVG</code>
    <p>True if the floating-point number on top of the fp stack is less than zero.  The fp number is removed from the floating-point stack, and the flag is left on top of the Forth parameter stack.</p>

<code>F0&gt;=		fp -- f</code>
    <p>True if the floating-point number on top of the fp stack is greater than or equal to zero.  The fp number is removed from the floating-point stack, and the flag is left on top of the Forth parameter stack.</p>

<code>F0&lt;=		fp -- f</code>
    <p>True if the floating-point number on top of the fp stack is less than or equal to zero.  The fp number is removed from the floating-point stack, and the flag is left on top of the Forth parameter stack.</p>

<code>F0&gt;		fp -- f					FVG</code>
    <p>True if the floating-point number on top of the fp stack is greater than zero.  The fp number is removed from the floating-point stack, and the flag is left on top of the Forth parameter stack.</p>

<code>F&lt;		fp1 fp2 -- f				FVG</code>
    <p>True if fp1 is less than fp2 .  The two floating-point numbers are removed from the floating-point stack, and the flag is left on top of the Forth parameter stack.</p>

<code>F&gt;		fp1 fp2 -- f				FVG</code>
    <p>True if fp1 is greater than fp2 .  The two floating-point numbers are removed from the floating-point stack, and the flag is left on top of the Forth parameter stack.</p>

<code>F&lt;=		fp1 fp2 -- f</code>
    <p>True if fp1 is less than or equal to fp2 .  The two floating-point numbers are removed from the floating-point stack, and the flag is left on top of the Forth parameter stack.</p>

<code>F&gt;=		fp1 fp2 -- f</code>
    <p>True if fp1 is greater than or equal to fp2 .  The two floating-point numbers are removed from the floating-point stack, and the flag is left on top of the Forth parameter stack.</p>

<code>F=		fp1 fp2 -- f					FVG</code>
    <p>True if fp1 is equal to fp2 .  The two floating-point numbers are removed from the floating-point stack, and the flag is left on top of the Forth parameter stack.</p>

<code>F&lt;&gt;		fp1 fp2 -- f</code>
    <p>True if fp1 is not equal to fp2 .  The two floating-point numbers are removed from the floating-point stack, and the flag is left on top of the Forth parameter stack.</p>

<code>FMAX		fp1 fp2 -- fp3</code>
    <p>fp3 is the larger of the 2 floating point numbers fp1 and fp2</p>

<code>FMIN		fp1 fp2 -- fp3</code>
    <p>fp3 is the smaller of the 2 floating point numbers fp1 and fp2</p>

<code>FCEIL		fp1 -- l</code>
    <p>l is the smallest integer which is as least as large as the floating point number fp1.  fp1 is removed from the floating point stack and the result is left on the parameter stack.</p>
	
<code>FFLOOR		fp1 -- l</code>
    <p>l is the largest integer which is not larger than the floating point number fp1.  fp1 is removed from the floating point stack and the result is left on the parameter stack.</p>
	
<code>FP!		n  --</code>
    <p>Store the integer on the parameter stack into the floating-point stack pointer.  Used for initialization.</p>

<code>FP@		-- addr</code>
    <p>Fetch the current contents of the floating-point stack pointer to the parameter stack.</p>

<code>FDEPTH		-- n</code>
    <p>n is the number of floating point numbers currently on the floating point stack.</p>

<code>FP0		-- addr</code>
    <p>addr is the address of a USER variable which contains the 32-bit address of the of the top of the floating point stack area.</p>
    <p>The stack grows towards low memory from there.  FP0 L@ FP!</p>
    <p>would empty the floating point stack, but see INITF .</p>

<code>FCLEAR		--</code>
    <p>Clears the floating point stack.</p>

<code>/F		-- n</code>
    <p>Leaves the size, in bytes, of a floating point number in storage format.  In this system, the value is 8.</p>

<code>(FLITERAL)	-- fp</code>
    <p>The run-time work compiled by fliteral which takes a floating point number from the executing code stream and leaves it on the floating point stack.</p>

<code>FLITERAL	fp --					C,I</code>
    <p>The floating point number is removed from the floating point stack and compiled into the current definition so that when the definition is later executed, that floating point number will be left on the floating point stack.</p>

    <h3>Floating point example:</h3>

    <p>This example prints a table of the values of the sine function at 1/10 radian intervals between 0 and two-pi.</p>

<pre>3.1415926535E0  2E0  f* fconstant 2pi</pre>
<pre>
: sine-table ( -- )
   0E0			( angle )
   begin
      fdup 2pi  f&lt;      ( angle end? )
   while
      fdup f.  fdup fsin  f.  cr
      .1E0   f+		( angle' )
   repeat
;
</pre>

</article>

</body>
</html>
